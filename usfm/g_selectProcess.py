# -*- coding: utf-8 -*-
# GUI interface for selecting a process to perform in the USFM Wizard.

from tkinter import *
from tkinter import ttk
from tkinter import font
from idlelib.tooltip import Hovertip
import os
import g_step

stepname = 'SelectProcess'   # equals the main class name in this module

class SelectProcess(g_step.Step):
    def __init__(self, mainframe, mainapp):
        super().__init__(mainframe, mainapp, stepname, "Start")
        self.frame = Select_Frame(mainframe, self)
        self.frame.grid(row=1, column=0, sticky="nsew")

    def name(self):
        return stepname

    def onNext(self):
        self.mainapp.set_process(self.values['selection'])
        self.mainapp.step_next()

class Select_Frame(g_step.Step_Frame):
    def __init__(self, parent, controller):
        super().__init__(parent, controller)

        self.process = StringVar()        
        subheadingFont = font.Font(size=10, slant='italic')     # normal size is 9
        suppressions_label = ttk.Label(self, text="What do you want to do today?", font=subheadingFont)
        suppressions_label.grid(row=3, column=1, columnspan=2, sticky=W, pady=(4,2))

        process1_rb = ttk.Radiobutton(self, text='Convert BTT-Writer text to USFM', variable=self.process,
                                      command=self._onRbChange, value='Txt2USFM')
        process1_rb.grid(row=4, column=1, sticky=W)
        process1_Tip = Hovertip(process1_rb, hover_delay=500,
             text="Convert a set of text files from BTT-Writer repos to USFM.")

        process2_rb = ttk.Radiobutton(self, text='Convert plain text to USFM', variable=self.process,
                                      command=self._onRbChange, value='Plaintext2Usfm')
        process2_rb.grid(row=5, column=1, sticky=W)
        process2_Tip = Hovertip(process2_rb, hover_delay=500,
             text="Convert plain text filed containing books of the Bible to usfm files.")

        process3_rb = ttk.Radiobutton(self, text='Verify and clean USFM', variable=self.process,
                                      command=self._onRbChange, value='VerifyUSFM')
        process3_rb.grid(row=6, column=1, sticky=W)
        process3_Tip = Hovertip(process3_rb, hover_delay=500,
             text="Verify and/or clean up existing USFM files.")

        process4_rb = ttk.Radiobutton(self, text='Convert USFM to USX', variable=self.process,
                                      command=self._onRbChange, value='Usfm2Usx')
        process4_rb.grid(row=7, column=1, sticky=W)
        process4_Tip = Hovertip(process4_rb, hover_delay=500,
             text="Produce a BTTW-compatible resource container from USFM.")

        self.columnconfigure(1, minsize=505)

    # Called when the frame is first activated. Populate the initial values.
    def show_values(self, values):
        self.values = values
        self.process.set(values['selection'])
        self._explain()
        self.controller.showbutton(psn=5, text=">>>",
                              tip="Begin the process you selected above.", cmd=self._onNext)
        self.controller.hidebutton(1,2,3,4)
        self._set_button_status()

    # Caches the current selection in self.values and calls the mainapp to save in the config file.
    def _save_values(self):
        self.values['selection'] = self.process.get()
        self.controller.mainapp.save_values(stepname, self.values)

    # Handles the radio button click event.
    def _onRbChange(self, *args):
        self.values['selection'] = self.process.get()
        self._explain()
        self._set_button_status()

    # Presents a detailed message about the selected process.
    def _explain(self, *args):
        self.message_area['state'] = NORMAL   # enables insertions to message area
        self.message_area.delete('1.0', 'end')
        match self.process.get():
            case 'Txt2USFM':
                self.message_area.insert('end',
"The “Convert text to USFM” process merges text files generated by BTT-Writer and converts them to USFM.\n\n\
It parses the manifest.json files to get the book ID and contributor names, and parses title.txt files to get the book titles. \
It creates one USFM file per book, with a proper header. \
The resulting files have standardized names, like 41-MAT.usfm and 42-MRK.usfm. \
It converts multiple books at once if there are multiple books.\n\n\
The resulting USFM file(s) need to be verified and probably cleaned up a bit.")
            case 'VerifyUSFM':
                self.message_area.insert('end', "Find and address issues in USFM files.")
            case 'Plaintext2Usfm':
                self.message_area.insert('end',
"This process converts SCripture text files, *not* of BTT-Writer origin, to USFM. \
To be converted, the text files must meet these conditions:\n\
  * Each file contains a single book of the Bible.\n\
  * No extraneous text in file.\n\
  * File names must be like XXX.txt (where XXX = book id).\n\
  * UTF-8 encoding is required.\n\
  * The first line of each file contains the book title.\n\
  * No other characters on first line.\n\
  * Chapter and verse numbers in Arabic numerals (0-9).\n\n\
The process creates one USFM file per book, with \
standardized names, like 41-MAT.usfm and 42-MRK.usfm. \
The resulting USFM file(s) need to be verified and probably cleaned up a bit.")
            case 'Usfm2Usx':
                self.message_area.insert('end',
"This process produces .usx and auxiliary files from USFM source text. \
This creates a “resource container” which BTT-Writer can then use as a new source text.\n\n\
Chunk boundaries are based on \s5 markers in the USFM files. \
The input file(s) should be verified, correct USFM. Therefore, the first step of this process is to validate the USFM files.")
            case _:
                self.message_area.insert(f"Internal error: process {self.process.get()} is not handled.")
        self.message_area.see('1.0')
        self.message_area['state'] = DISABLED   # prevents editing of message area


    # Required ABC methods
    def _save_values(self):
        pass
    def _onExecute(self, *args):
        pass
    def onScriptEnd(self, nIssues):
        pass

    def _set_button_status(self):
        # okay = self.process.get() in {'Txt2USFM', 'VerifyUSFM', 'Plaintext2Usfm', 'Usfm2Usx'}
        self.controller.enablebutton(5, True)
